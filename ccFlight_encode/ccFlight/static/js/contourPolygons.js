class ContourPolygons {
    // array of MultiPolygon objects generated by d3.contour
    constructor(multiPolygons) {
        this.levelRegions = [];     // 多层轮廓多边形

        for (const multiPolygon of multiPolygons) {
            let polygons = disassembleMultiPolygon(multiPolygon);
            let value = multiPolygon.value;
            this.levelRegions.push({value: value, polygons: polygons})
        }
        this.levelRegions.sort((a, b) => b.value - a.value);     // 降序

        this.flights = new Array(this.levelRegions.length);      // levelRegions-polygonID: flights list
        this.mainAirports = new Array(this.levelRegions.length); // levelRegions-polygonID: main airports list
        this.probsDay = new Array(this.levelRegions.length);
        // this.probsGlobal = new Array(this.levelRegions.length);
        // this.probsDiff = new Array(this.levelRegions.length);    // 影响要素列表, 降序排列
        this.probsColor = new Array(this.levelRegions.length);  // [color, value]
        this.hierarchy = new Array(this.levelRegions.length);    // levelRegions-polygonID: 包含的上一层多边形列表
    }

    get lowestLevel() {
        return this.levelRegions.length - 1
    }

    getNumRegions(regionLevel) {
        if (regionLevel <= this.lowestLevel)
            return this.levelRegions[regionLevel].polygons.length
    }

    getRegionPoly(regionLevel, polygonID) {
        if (regionLevel <= this.lowestLevel) {
            const polygons = this.levelRegions[regionLevel].polygons;
            if (polygonID < polygons.length) {
                return polygons[polygonID]
            }
        }
    }

    getRegionFillColors(regionLevel, polygonID) {
        // if (regionLevel <= this.lowestLevel && polygonID < this.getNumRegions(regionLevel))
        if (regionLevel === 0 && polygonID < this.getNumRegions(0))
            return this.probsColor[regionLevel][polygonID]
    }

    // 在不同的区域显示其中机场的概率数据
    // 数据: 航班数据及机场\多层区域多边形

    // regionLevel: [0,...], 0是最高级,面积最小

    // 输入航班, 提供leaflet地图, 按照屏幕上多边形的包含关系分开存储
    groupFlightsByRegion(flights, regionLevel, map) {
        let polygons = this.levelRegions[regionLevel].polygons;
        this.flights[regionLevel] = new Array(polygons.length);

        for (let i = 0; i < polygons.length; i++) {
            const poly = polygons[i];
            this.flights[regionLevel][i] = [];

            for (let flight of flights) {
                let pos = map.latLngToContainerPoint(flight.epLoc);
                pos = [pos.x, pos.y]
                if (polygonHoledContains(poly, pos)) {
                    this.flights[regionLevel][i].push(flight)
                }
            }
        }
        // console.log(this.flights)
    }

    // 找到区域的主要机场
    groupMainAirportsByRegion(regionLevel, map) {
        let polygons = this.levelRegions[regionLevel].polygons;
        this.mainAirports[regionLevel] = new Array(polygons.length);

        for (let i = 0; i < polygons.length; i++) {
            const poly = polygons[i];
            this.mainAirports[regionLevel][i] = [];

            for (let airport in mainAirports) {
                // if (!mainAirports.hasOwnProperty(airport)) continue;
                let pos = map.latLngToContainerPoint(mainAirports[airport]);
                pos = [pos.x, pos.y];
                if (polygonHoledContains(poly, pos)) {
                    this.mainAirports[regionLevel][i].push(airport)
                }
            }
        }
        // console.log(this.mainAirports)
    }

    // 获取本区域在所有时间数据中的impact_prob
    getRegionProbsGlobal(regionLevel, polygonID, bnprobs) {
        function aver(array1, array2) {
            let arr_key = _.keys(array1);
            let aver_result = [];
            for (const key_element of arr_key) {
                aver_result[key_element] = [];
                for (let i = 0; i < array1[key_element].length; i++) {
                    const arr_element = (array1[key_element][i] + array2[key_element][i]) / 2;
                    aver_result[key_element].push(arr_element)
                }
            }
            return aver_result
        }

        let airportsInRegion = this.mainAirports[regionLevel][polygonID];
        if (!airportsInRegion || airportsInRegion.length === 0) return null;

        let airport_info = _.values(bnprobs),   // underscore.js
            airport_name = _.keys(bnprobs);

        let result;
        // console.log('main airport number in region', airportsInRegion.length)
        switch (airportsInRegion.length) {
            case 1:
                let airport = airportsInRegion[0];
                result = airport_info[_.indexOf(airport_name, airport)][2];
                break;
            case 2:
                let [airport1, airport2] = airportsInRegion;
                let impact_prob1 = airport_info[_.indexOf(airport_name, airport1)][2];
                let impact_prob2 = airport_info[_.indexOf(airport_name, airport2)][2];
                result = aver(impact_prob1, impact_prob2);
                break;
            default:
                break
        }
        this.probsGlobal[regionLevel][polygonID] = result

        // console.log('getRegionProbsGlobal', result);
        return result
    }

    // 获得本区域在输入的数据中的因素概率矩阵
    getRegionProbsDay(regionLevel, polygonID) {
        let flights = this.flights[regionLevel][polygonID];
        if (!flights) return null;

        // 初始化矩阵
        let dayStatisticMat = {
            Dde: [0, 0, 0, 0], // 等级从1~4,减1作为索引
            Dr15: [0, 0, 0, 0],
            Dr30: [0, 0, 0, 0],
            Dr60: [0, 0, 0, 0],
        };

        // 遍历本区域航班, 统计局部概率
        for (let flight of flights) {
            dayStatisticMat.Dde[segDelay(flight.flightDelay) - 1]++;
            dayStatisticMat.Dr15[flight.cnt_p15 > 0 ? segRate(flight.cnt_d15 / flight.cnt_p15) : 0]++;
            dayStatisticMat.Dr30[flight.cnt_p30 > 0 ? segRate(flight.cnt_d30 / flight.cnt_p30) : 0]++;
            dayStatisticMat.Dr60[flight.cnt_p60 > 0 ? segRate(flight.cnt_d60 / flight.cnt_p60) : 0]++;
        }

        // 归一化, 矩阵所有值除以航班数
        for (let factor in dayStatisticMat) {
            for (let j = 0; j < dayStatisticMat[factor].length; j++) {
                dayStatisticMat[factor][j] /= flights.length
            }
        }
        this.probsDay[regionLevel][polygonID] = dayStatisticMat;

        // console.log('getRegionProbsDay', dayStatisticMat)
        return dayStatisticMat
    }

    // 返回局部-全局概率差值矩阵
    getRegionProbsDiff(regionProbs, regionProbsDay) {
        // 差值矩阵: 局部减全局差值的矩阵
        let dayStatisticDiffMat = {
            Dde: [0, 0, 0, 0], // 等级从1~4,减1作为索引
            Dr15: [0, 0, 0, 0],
            Dr30: [0, 0, 0, 0],
            Dr60: [0, 0, 0, 0],
        };
        for (let factor in dayStatisticDiffMat) {
            if (!dayStatisticDiffMat.hasOwnProperty(factor)) continue;
            for (let j = 0; j < dayStatisticDiffMat[factor].length; j++) {
                dayStatisticDiffMat[factor][j] = Math.abs(regionProbsDay[factor][j] - regionProbs[factor][j]);
            }
        }

        // console.log('局部差值矩阵', dayStatisticDiffMat)
        return dayStatisticDiffMat
    }

    // 主要调用
    processProbsDiff(bnprobs) {
        let regionLevel = 0;
        let polygons = this.levelRegions[regionLevel].polygons;
        let numLevel = polygons.length;

        // this.probsGlobal[regionLevel] = new Array(numLevel);
        this.probsDay[regionLevel] = new Array(numLevel);
        // this.probsDiff[regionLevel] = new Array(numLevel);
        this.probsColor[regionLevel] = new Array(numLevel);

        for (let i = 0; i < polygons.length; i++) {
            let probsDay = this.getRegionProbsDay(regionLevel, i);
            probsDay = this.probsMat2Arr(probsDay);

            let colors = []
            // let color1 = null, color2 = null
            // for (let probItem of probsDay) {
            //     let c=[lookupColor(probItem.factor, probItem.factorLv),probItem.val]
            //     if (probItem.factor === 'Dde' && !color1) {
            //         color1 = c
            //     } else if (probItem.factor !== 'Dde' && !color2) {
            //         color2 = c
            //     }
            // }
            // colors=[color1,color2]

            let color1 = null, color2 = null, color3 = null, color4 = null
            for (let probItem of probsDay) {
                let c = [lookupColor(probItem.factor, probItem.factorLv), probItem.val]
                if (probItem.factor === 'Dde' && !color1) {
                    color1 = c
                } else if (probItem.factor === 'Dr15' && !color2) {
                    color2 = c
                } else if (probItem.factor === 'Dr30' && !color3) {
                    color3 = c
                } else if (probItem.factor === 'Dr60' && !color4) {
                    color4 = c
                }
            }
            colors = [color1, color2, color3, color4]

            this.probsColor[regionLevel][i] = colors
        }

        // // 自上向下遍历层
        // for (regionLevel = 1; regionLevel <= this.lowestLevel; regionLevel++) {
        //
        //     // 找到包含在内的0层多边形
        //     const polygons = this.levelRegions[regionLevel].polygons;
        //     this.probsColor[regionLevel] = new Array(polygons.length);
        //
        //     for (let j = 0; j < polygons.length; j++) {
        //         this.probsColor[regionLevel][j] = [];
        //
        //         const poly = polygons[j];
        //
        //         // 遍历0层多边形
        //         for (let k = 0; k < this.levelRegions[0].polygons.length; k++) {
        //             if (!this.probsDay[0][k]) continue
        //             // if (!this.probsDiff[0][k]) continue
        //             const topPoly = this.levelRegions[0].polygons[k];
        //             if (this.polyContainsPoly(poly, topPoly)) {
        //                 // 取出topPoly区域中的第regionLevel排序的要素
        //                 let probItem = this.probsDay[0][k][regionLevel]
        //                 // let probItem = this.probsDiff[0][k][regionLevel]
        //                 let color = lookupColor(probItem.factor, probItem.factorLv);
        //                 this.probsColor[regionLevel][j].push([color, probItem.val])
        //             }
        //         }
        //     }
        // }
    }

    polyContainsPoly(polyLarge, polySmall) {
        let p = polySmall.coordinates[0][0];   // 外边界第一个点
        // 若低层多边形包含高层多边形的一个点就必然完全包含这个高层多边形
        return polygonHoledContains(polyLarge, p)
    }


    buildContainHierarchy() {
        // 自上向下遍历层
        for (let regionLevel = 1; regionLevel < this.lowestLevel; regionLevel++) {
            if (!(regionLevel in this.hierarchy))
                this.hierarchy[regionLevel] = {};

            // 找到包含在内的0层多边形
            const polygons = this.levelRegions[regionLevel].polygons;

            for (let j = 0; j < polygons.length; j++) {
                if (!(j in this.hierarchy[regionLevel]))
                    this.hierarchy[regionLevel][j] = [];

                const poly = polygon[j];
                // 遍历上一层多边形
                for (let k = 0; k < this.levelRegions[regionLevel - 1].polygons.length; k++) {
                    const topPoly = this.levelRegions[0].polygons[k];
                    if (this.polyContainsPoly(poly, topPoly)) {
                        this.hierarchy[regionLevel][j].push(k)
                    }
                }
            }
        }
    }

    probsMat2Arr(mat) {
        let arr = [];
        for (let factor in mat) {
            if (!mat.hasOwnProperty(factor)) continue;
            for (let j = 0; j < mat[factor].length; j++) {
                const val = mat[factor][j];
                arr.push({factor: factor, factorLv: j, val: val})
            }
        }
        arr.sort((a, b) => b.val - a.val);   // 降序
        return arr
    }
}
